---
title: "Using-EpiStainDynamics"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using-EpiStrainDynamics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---





EpiStrainDynamics extends an existing statistical modelling framework capable of inferring the trends of up to two pathogens. The modeling framework has been extended here to handle any number of pathogens; fit to time series data of counts (eg, daily number of cases); incorporate influenza testing data in which the subtype for influenza A samples may be undetermined; account for day-of-the-week effects in daily data; include options for fitting penalized splines or random walks; support additional (optional) correlation structures in the parameters describing the smoothness of the penalized splines (or random walks); and account for additional (optional) sources of noise in the observation process.

# Step 1: Construct model

These modelling specifications are specified using the `construct_model` function. The correct stan model is then applied based on the specifications provided. `construct_model()` takes three arguments: `method`, `pathogen_structure`, and `dow_effect`. We will break these down one by one.

## Method

EpiStrainDynamics has pre-compiled stan models that fit either with bayesian penalised splines or random walks. These are specified using the `method` argument of `construct_model()` as functions, either with `random_walk()` or `p_spline()`. The penalised spline model has two further options to specify: `spline_degree` is the polynomial degree of the individual spline segments used to construct the overall curve (must be a positive whole number) and `days_per_knot`, which is the number of days for each knot (must also be a positive whole number).

So we may specify:
```
mod <- construct_model(
  method = random_walk(),
  ...
)
# OR

mod <- construct_model(
  method = p_spline(spline_degree = 3, days_per_knot = 2),  # example options
  ...
)
```

## Pathogen structure

There are three main types of pathogen structure available to model: `single()`, `multiple()`, and `subtyped()`.

The `single()` pathogen structure is the simplest and models a single pathogen timeseries. A vector is the case timeseries is provided to the argument `case_timeseries`, a vector of date or time labels is provided to `time`, and optionally a pathogen name can be assigned with `pathogen_name`. It can be specified as follows, illustrated using data provided with the package `sarscov2`:

```
single(
  case_timeseries = sarscov2$cases,           # timeseries of case data
  time = sarscov2$date,                       # date or time variable labels
  pathogen_name = 'SARS-COV-2'                # optional name of pathogen
)
```

The `multiple()` and `subtyped()` pathogen structures both also have the `case_timeseries` and `time` arguments, as in the `single()` structure.

In addition to these two arguments, instead of a single argument for `pathogen_name`, `multiple()` and `subtyped()` have one or more arguments that allow the user to define the names and data for the different components or subtypes to be modelled. For `multiple()`, these are specified as a named list with the argument `component_pathogen_timeseries`. The names in this list will be using in subsequent plotting. For `subtyped()`, which allows the user to incorporate testing data for influenza A subtypes, a vector of total unsubtyped influenza A cases is specified with `influenzaA_unsubtyped_timeseries`, a named list of the subtyped influenza A timeseries is provided to `influenzaA_subtyped_timeseries`, and further pathogens are provided in a named list to `other_pathogen_timeseries`.

In addition to specifying the data and pathogen names, `multiple()` and `subtyped()` both allow the user to modify the correlation structures in the parameters describing the smoothness (with argument `smoothing_structure`) and account for additional sources of noise in the observation process (`observation_noise`). `smoothing_structure` is either `'shared'` (all pathogens have the same smoothness), `'independent'` (each pathogen has completely independent smoothing structure), or `'correlated'` (smoothing structure is correlated among pathogens). `observation_noise` is either `'observation_noise_only'` (only includes observation noise - the same between pathogens) or `'pathogen_specific_noise'` (includes noise in individual pathogens as well).

Example pathogen structure specification for multiple pathogens model:
```
multiple(
   case_timeseries = sarscov2$cases,        # timeseries of case data
   time = sarscov2$date,                    # date or time variable labels

   component_pathogen_timeseries = list(    # named list of component pathogens
     alpha = sarscov2$alpha,
     delta = sarscov2$delta,
     omicron = sarscov2$omicron,
     other = sarscov2$other
   ),

   smoothing_structure = 'independent',             # correlation structures
   observation_noise = 'observation_noise_only'     # observation noise
 )
```

Example pathogen structure specification for subtyped model:
```
subtyped(
   case_timeseries = influenza$ili,         # timeseries of case data
   time = influenza$week,                   # date or time variable labels

   influenzaA_unsubtyped_timeseries = influenza$inf_A,  # unsubtyped influenzaA
   influenzaA_subtyped_timeseries = list(       # named list of subtyped infA
     H3N2 = influenza$inf_H3N2,
     H1N1 = influenza$inf_H1N1
   ),
   other_pathogen_timeseries = list(            # named list of other pathogens
     influenzaB = influenza$inf_B,
     other = influenza$num_spec - influenza$inf_all
   ),

   smoothing_structure = 'correlated',            # correlation structures
   observation_noise = 'pathogen_specific_noise'  # observation noise
 )
```

## Day of week effect

Day of week effect is specified as a logical (`TRUE` or `FALSE`) to the `dow_effect` argument. In plotting the day of week effect can be selectively removed.

```
mod <- construct_model(
  method = ...,
  pathogen_structure = ...,
  dow_effect = TRUE
)
```



The constructed model object is a named list containing input data, accessed with `$data`, parameter values (such as smoothing structure, observation noise, and penalised spline parameters, if appropriate), accessed with `model_params`, names of provided pathogens, accessed with `pathogen_names`, and record of whether day of week effect has been selected, accessed with `dow_effect`.

# Step 2: Fit model

The model estimates the expected value of the time series (eg, a smoothed trend in the daily number of cases accounting for noise) for each individual pathogen. Model parameterisation decisions specified when constructing the model in step 1 mean the correct stan model will be applied at this stage by simply calling `fit_model()` onto the constructed model object.


``` r
fit <- fit_model(
  mod,
  iter = 2000,
  warmup = 1000,
  chains = 3
)
```

The output of this function is a list with the stan fit object, accessed with `$fit`, and the elements of the constructed model object from the previous step, accessed with `$constructed_model`.

The stan fit object can be interrogated with any package that works with stan outputs. One could visualise posteriors, for example with the package `bayesplot`:


``` r
library(bayesplot)
#> This is bayesplot version 1.14.0
#> - Online documentation and vignettes at mc-stan.org/bayesplot
#> - bayesplot theme set to bayesplot::theme_default()
#>    * Does _not_ affect other ggplot2 plots
#>    * See ?bayesplot_theme_set for details on theme setting
mcmc_area(as.matrix(fit$fit), pars = 'tau', prob = 0.8)
#> Error in mcmc_area(as.matrix(fit$fit), pars = "tau", prob = 0.8): could not find function "mcmc_area"
```

The `bayesplot` package can also be used to evaluate convergence:


``` r
mcmc_trace(rstan::extract(fit$fit, permuted = FALSE), pars = c('a[1]'))
#> Error in `select_parameters()`:
#> ! Some 'pars' don't match parameter names: a[1] FALSE
```

Or else the application `shinystan` is a great tool to visualise the fit and diagnose issues:


``` r
library(shinystan)
launch_shinystan(fit$fit)
```

# Step 3: Calculate and explore epidemiological quantities

The package provides helper functions to calculate a number of useful epidemiological quantities. The output of these methods functions  are a named list containing a data frame of the outcome quantity (`$measure`), the fit object (`$fit`), and the constructed model object (`$constructed_model`). `measure` is a data frame containing the median of the epidemiological quantity (`y`), the 50% credible interval of the quantity (`lb_50` & `ub_50`), the 95% credible interval (`lb_95` & `ub_95`), the proportion greater than a defined threshold value (`prop`), the pathogen name (`pathogen`), and the time label (`time`).

Calculate epidemic growth rate with `growth_rate()`:

``` r
gr <- growth_rate(fit)
head(gr$measure)
#>   pathogen pathogen_idx          y         lb_50      ub_50
#> 1    Total           NA 0.03698827 -0.0089480085 0.08706294
#> 2    Total           NA 0.03972700 -0.0002951054 0.07915102
#> 3    Total           NA 0.03678505  0.0066676300 0.06701464
#> 4    Total           NA 0.03218735  0.0065694847 0.05737864
#> 5    Total           NA 0.02799872  0.0034695705 0.05295108
#> 6    Total           NA 0.02606898  0.0036616871 0.04803510
#>         lb_95      ub_95      prop       time
#> 1 -0.09949339 0.18583034 0.7086667 2012-01-09
#> 2 -0.07437469 0.15766399 0.7480000 2012-01-16
#> 3 -0.04990268 0.12807260 0.7936667 2012-01-23
#> 4 -0.04024085 0.10721439 0.8116667 2012-01-30
#> 5 -0.04507178 0.10040364 0.7816667 2012-02-06
#> 6 -0.03690913 0.08900377 0.7860000 2012-02-13
plot(gr)
```

![plot of chunk growth_rate](figure/growth_rate-1.png)

Calculate effective reproduction number over time with `Rt()` (requiring specification of a generation interval distribution):

``` r
rt <- Rt(fit, gi_dist = function(x) 4*x*exp(-2*x))
plot(rt)
```

![plot of chunk Rt](figure/Rt-1.png)

Calculate incidence with or without a day of week effect with `incidence()`:

``` r
inc_dow <- incidence(fit, dow = TRUE)
plot(inc_dow)
```

![plot of chunk incidence](figure/incidence-1.png)

Calculate proportions of different combinations of cases attributable to different pathogens/subtypes using `proportion()`. By default, the function will return a dataframe with proportions of each pathogen or subtype out of all pathogens/subtypes. Alternatively, one can specify a selection of pathogens/subtypes by their names in the named lists provided to `construct_model()`:
```
prop <- proportion(
  fit,
  numerator_combination = c('alpha', 'delta', 'omicron'),
  denominator_combination = c('alpha', 'delta', 'omicron', 'other')
)
```


``` r
prop <- proportion(fit)
plot(prop)
```

![plot of chunk proportion](figure/proportion-1.png)
