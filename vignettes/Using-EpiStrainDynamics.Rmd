---
title: "Using EpiStrainDynamics"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using EpiStrainDynamics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



EpiStrainDynamics extends an existing statistical modelling framework capable of inferring the trends of up to two pathogens. The modeling framework has been extended here to handle any number of pathogens; fit to time series data of counts (eg, daily number of cases); incorporate influenza testing data in which the subtype for influenza A samples may be undetermined; account for day-of-the-week effects in daily data; include options for fitting penalized splines or random walks; support additional (optional) correlation structures in the parameters describing the smoothness of the penalized splines (or random walks); and account for additional (optional) sources of noise in the observation process.

# Step 1: Construct model

These modelling specifications are specified using the `construct_model` function. The correct stan model is then applied based on the specifications provided. `construct_model()` requires specification of the `method` and `pathogen_structure`, and allows the user to additionally specify four arguments related to model design: `smoothing_params`, `dispersion_params`, `pathogen_noise`, and `dow_effect`. We will break these down one by one.

## Method

EpiStrainDynamics has pre-compiled stan models that fit either with bayesian penalised splines or random walks. These are specified using the `method` argument of `construct_model()` as functions, either with `random_walk()` or `p_spline()`. The penalised spline model has two further options to specify: `spline_degree` is the polynomial degree of the individual spline segments used to construct the overall curve (must be a positive whole number) and `days_per_knot`, which is the number of days for each knot (must also be a positive whole number).

So we may specify:
```
method = random_walk(),

# OR

method = p_spline(spline_degree = 3,  # example value for spline degree
                  days_per_knot = 2)  # example value for days per knot
```

## Pathogen structure

There are three main types of pathogen structure available to model: `single()`, `multiple()`, and `subtyped()`.
These functions require the name of the dataset itself and the column names for different data elements. These can also ingest timeseries class objects, which would then make the `time` column specification optional. The models are not currently equipped to handle missing values or irregular date sequences. Timeseries checks are run internally on data frame or any time of timeseries class input that is handled by the [`tsbox` package](https://docs.ropensci.org/tsbox/reference/tsbox-package.html).

The `single()` pathogen structure is the simplest and models a single pathogen timeseries. The name of the dataframe is passed to argument `data`, the name of the column with total case data is passed to `case_timeseries`, and the name of the column of time data is passed to `time` (optional if input dataset is a timeseries class). It can be specified as follows, illustrated using data provided with the package `sarscov2`:

```
pathogen_structure = single(
  data = sarscov2,                    # dataframe
  case_timeseries = 'cases',          # timeseries of case data
  time = 'date'                       # date or time variable
)
```

The `multiple()` pathogen structure allows modelling of different component pathogens. In addition to specifying `data`, `case_timeseries`, and `time` (optional if input dataset is a timeseries class), these additional pathogens are specified as a vector of column names with the argument `component_pathogen_timeseries`. Example pathogen structure specification for multiple pathogens model using the `sarscov2` dataset:

```
pathogen_structure = multiple(
  data = sarscov2,                         # dataframe
  case_timeseries = 'cases',               # timeseries of case data
  time = 'date',                           # date or time variable labels

  component_pathogen_timeseries = c(       # vector of column names of
    'alpha', 'delta', 'omicron', 'other'   #   component pathogens
  )
)
```

The `subtyped()` pathogen structure enables additional complexity specifically for an influenza modelling scenario by allowing the user to incorporate testing data for influenza A subtypes. The unsubtyped column is specified with `influenzaA_unsubtyped_timeseries`, and the subtyped data are specified with vector of column names of provided to `influenzaA_subtyped_timeseries`. Additional pathogens are provided as a vector of column names to `other_pathogen_timeseries`. Example pathogen structure specification for subtyped model using the `influenza` dataset included in the package:

```
pathogen_structure = subtyped(
  data = influenza,                            # dataframe
  case_timeseries = ili,                       # timeseries of case data
  time = week,                                 # date or time variable labels

  influenzaA_unsubtyped_timeseries = 'inf_A',  # unsubtyped influenzaA
  influenzaA_subtyped_timeseries = c(          # subtyped influenzaA
    'inf_H3N2', 'inf_H1N1'
  ),
  other_pathogen_timeseries = c(               # other pathogens
    'inf_B', 'other'
  )
)
```

## Smoothing parameters

The argument `smoothing_params` allows users to modify the correlation structures in the parameters describing smoothness and set related priors. These are specified with the function `smoothing_structure()` that requires the user to specify a `smoothing_type` that is either `shared` (all pathogens have the same smoothness), `independent` (each pathogen has completely independent smoothing structure), or `correlated` (smoothing structure is correlated among pathogens). For `shared` or `independent` smoothing types parameters for the mean and standard deviation of the prior on tau can also be specified, as below:

```
smoothing_params = smoothing_structure(
  smoothing_type = 'independent',
  tau_mean = c(0, 0.1, 0.3, 0),
  tau_sd = rep(1, times = 4)
)
```

## Dispersion parameters

The argument `dispersion_params` allows users to set a prior for the overdispersion parameter of the negative binomial likelihood for the case timeseries. It is specified using `dispersion_structure()` as below:

```
dispersion_params = dispersion_structure(
  phi_mean = 0, phi_sd = 1
)
```

## Pathogen noise

Whether to include noise between individual pathogens as well as the observation noise is specified as a logical (`TRUE` or `FALSE`) to the argument `pathogen_noise`.

## Day of week effect

Day of week effect is specified as a logical (`TRUE` or `FALSE`) to the `dow_effect` argument. In plotting the day of week effect can be selectively removed.

## Worked example

A full worked example using a subtyped structure:


``` r
mod <- construct_model(

  method = p_spline(),

  pathogen_structure = subtyped(
    data = influenza,
    case_timeseries = 'ili',
    time = 'week',
    influenzaA_unsubtyped_timeseries = 'inf_A',
    influenzaA_subtyped_timeseries = c('inf_H3N2', 'inf_H1N1'),
    other_pathogen_timeseries = c('inf_B', 'other')
  ),

  smoothing_params = smoothing_structure(
    'independent', tau_mean = c(0, 0.1, 0.3, 0), tau_sd = rep(1, times = 4)),
  dispersion_params = dispersion_structure(phi_mean = 0, phi_sd = 1),
  pathogen_noise = FALSE,
  dow_effect = TRUE
)
```

## Output

The constructed model object is a named list containing the formatted data to be modelled, accessed with `$data`, a timeseries object of class `tsibble` that has been validated for gaps and regularity, accessed with `$validated_tsbl`, parameter values structured for the stan interface (such as smoothing structure, observation noise, and penalised spline parameters, if appropriate), accessed with `model_params`, names of provided pathogens, accessed with `pathogen_names`, and record of whether day of week effect has been selected, accessed with `dow_effect`.

# Step 2: Fit model

The model estimates the expected value of the time series (eg, a smoothed trend in the daily number of cases accounting for noise) for each individual pathogen. Model parameterisation decisions specified when constructing the model in step 1 mean the correct stan model will be applied at this stage by simply calling `fit_model()` onto the constructed model object.


``` r
fit <- fit_model(
  mod,
  n_iter = 2000,
  n_warmup = 1000,
  verbose = FALSE
)
```

The output of this function is a list with the stan fit object, accessed with `$fit`, and the elements of the constructed model object from the previous step, accessed with `$constructed_model`.

## Step 3: Check fit

A summary of model convergence diagnostics can be viewed using:


``` r
diagnose_model(fit)
#> Model Convergence Diagnostics
#> =============================
#> Overall convergence: GOOD 
#> Maximum R-hat: 1.006 
#> Minimum n_eff: 976
```

Beyond this summary, the stan fit object can be interrogated with any package that works with stan outputs. For example, one could visualise posteriors with the package `bayesplot`:


``` r
bayesplot::mcmc_areas(as.matrix(fit$fit), pars = 'tau[1]', prob = 0.8)
```

![plot of chunk unnamed-chunk-5](vignettes/figures/Using-EpiStrainDynamics-unnamed-chunk-5-1.png)

The `bayesplot` package can also be used to evaluate convergence:


``` r
bayesplot::mcmc_trace(rstan::extract(fit$fit, permuted = FALSE), pars = c('a[1,1]'))
```

![plot of chunk unnamed-chunk-6](vignettes/figures/Using-EpiStrainDynamics-unnamed-chunk-6-1.png)

Or else the application `shinystan` is a great tool to visualise the fit and diagnose issues:

```
library(shinystan)
launch_shinystan(fit$fit)
```

Model not converging? You can find more information about divergent transitions [here](https://mc-stan.org/docs/2_19/reference-manual/divergent-transitions). Some quick tips:

* Increase the `adapt_delta` parameter in fit_model(), which governs how big the steps are in the MCMC.
* Try reducing the complexity of the model. For example, by using `pathogen_noise = FALSE` or a shared smoothing structure.
* Increase the number of warmup samples with the n_warmup parameter.

# Step 3: Calculate and explore epidemiological quantities

The package provides helper functions to calculate a number of useful epidemiological quantities. The output of these methods functions are a named list containing a tsibble of the outcome quantity (`$measure`), the fit object (`$fit`), and the constructed model object (`$constructed_model`). `measure` is a tsibble containing the median of the epidemiological quantity (`y`), the 50% credible interval of the quantity (`lb_50` & `ub_50`), the 95% credible interval (`lb_95` & `ub_95`), the proportion greater than a defined threshold value (`prop`), the pathogen name (`pathogen`), and the time index (`time`).

Calculate epidemic growth rate with `growth_rate()`:

``` r
gr <- growth_rate(fit)
head(gr$measure)
#> # A tsibble: 6 x 9 [7D]
#> # Key:       pathogen [1]
#>   pathogen pathogen_idx      y    lb_50  ub_50   lb_95  ub_95  prop time      
#>   <chr>           <int>  <dbl>    <dbl>  <dbl>   <dbl>  <dbl> <dbl> <date>    
#> 1 Total              NA 0.0422 -0.00574 0.0879 -0.0936 0.184  0.722 2012-01-09
#> 2 Total              NA 0.0411  0.00408 0.0803 -0.0692 0.157  0.774 2012-01-16
#> 3 Total              NA 0.0378  0.00858 0.0698 -0.0472 0.132  0.807 2012-01-23
#> 4 Total              NA 0.0343  0.00676 0.0599 -0.0382 0.112  0.808 2012-01-30
#> 5 Total              NA 0.0306  0.00430 0.0546 -0.0421 0.105  0.788 2012-02-06
#> 6 Total              NA 0.0268  0.00451 0.0500 -0.0374 0.0941 0.788 2012-02-13
plot(gr)
```

![plot of chunk growth_rate](vignettes/figures/Using-EpiStrainDynamics-growth_rate-1.png)

Calculate effective reproduction number over time with `Rt()` (requiring specification of a generation interval distribution):

``` r
rt <- Rt(fit, gi_dist = function(x) 4*x*exp(-2*x))
plot(rt)
```

![plot of chunk Rt](vignettes/figures/Using-EpiStrainDynamics-Rt-1.png)

Calculate incidence with or without a day of week effect with `incidence()`:

``` r
inc_dow <- incidence(fit, dow = TRUE)
plot(inc_dow)
#> Error in plot.incidence(inc_dow): object 'inc' not found
```

Calculate proportions of different combinations of cases attributable to different pathogens/subtypes using `proportion()`. By default, the function will return a dataframe with proportions of each pathogen or subtype out of all pathogens/subtypes. Alternatively, one can specify a selection of pathogens/subtypes by their names in the named lists provided to `construct_model()`:
```
prop <- proportion(
  fit,
  numerator_combination = c('inf_H3N2', 'inf_H1N1'),
  denominator_combination = c('inf_H3N2', 'inf_H1N1', 'inf_B', 'other')
)
```


``` r
prop <- proportion(fit)
#> Error in splineDesign(Aknots, x, ord): length of 'derivs' is larger than length of 'x'
plot(prop)
#> Error: object 'prop' not found
```
